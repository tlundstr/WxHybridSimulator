package wxhybridsimulator.admin;

// -----( IS Java Code Template v1.2

import com.wm.data.*;
import com.wm.util.Values;
import com.wm.app.b2b.server.Service;
import com.wm.app.b2b.server.ServiceException;
// --- <<IS-START-IMPORTS>> ---
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
// --- <<IS-END-IMPORTS>> ---

public final class db

{
	// ---( internal utility methods )---

	final static db _instance = new db();

	static db _newInstance() { return new db(); }

	static db _cast(Object o) { return (db)o; }

	// ---( server methods )---




	public static final void closeDB (IData pipeline)
        throws ServiceException
	{
		// --- <<IS-START(closeDB)>> ---
		// @sigtype java 3.5
		Connection lCon = null;
		try {
			lCon= getDatabaseConnection();
			Statement stmt = lCon.createStatement();
			//Drop Each of the Tables
			String[] lTables = getTables();
			for (int li=0; li < lTables.length; li++){
				stmt.executeUpdate("DROP TABLE "+lTables[li]);
			}
			lCon.close();
			mCon = null;
		} 
		catch (SQLException e) {
			IDataCursor pipelineCursor_1 = pipeline.getCursor();
			IDataUtil.put( pipelineCursor_1, "DBError", "Cannot create Tables: "+e.getMessage());
			pipelineCursor_1.destroy();
		}
		// --- <<IS-END>> ---

                
	}



	public static final void createTable (IData pipeline)
        throws ServiceException
	{
		// --- <<IS-START(createTable)>> ---
		// @sigtype java 3.5
		// [i] field:0:required tableName
		// [i] record:0:required document
		// [o] field:0:required success
		// --- <<IS-END>> ---

                
	}



	public static final void getTables (IData pipeline)
        throws ServiceException
	{
		// --- <<IS-START(getTables)>> ---
		// @sigtype java 3.5
		// [o] field:1:required TableNames
		String[] lTableNames = null;
		try {
			lTableNames = getTables();
		 } catch (Exception e) {
		            e.printStackTrace();
		 }
		
		// pipeline
		String[]	TableNames = new String[1];
		TableNames[0] = "TableNames";
		
		IDataCursor pipelineCursor = pipeline.getCursor();
		IDataUtil.put( pipelineCursor, "TableNames", lTableNames );
		pipelineCursor.destroy();
		// --- <<IS-END>> ---

                
	}



	public static final void openDB (IData pipeline)
        throws ServiceException
	{
		// --- <<IS-START(openDB)>> ---
		// @sigtype java 3.5
		Connection lCon = null;
		 IData[] lIdtab = null;
		 boolean lExistTable = false;
		 try {
			 lCon= getDatabaseConnection();
			
			if( !existTable("CUSTOMER")){ 
				executeQuery(lCon,"CREATE TABLE CUSTOMER ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR(100),reg_number VARCHAR(50),address VARCHAR(150),country VARCHAR(150),creditrating VARCHAR(5),industry VARCHAR(50),contact VARCHAR(100),email VARCHAR(100),phone VARCHAR(50))");
				executeQuery(lCon,"INSERT INTO CUSTOMER VALUES (1, 'Acme inc','112233','Acmestreet 1','USA','BBB','Insurance', 'Andrew smith', 'andrew.smith@acme.com','112233')");
				executeQuery(lCon,"INSERT INTO CUSTOMER VALUES (2, 'IBM','445566','Vasagatan 16, 111 20 Stockholm','SWEDEN','AAA','IT', 'Thomas Lundstr\u00F6m', 'thomas.lundstrom@ibm.com','0703908120')");
				executeQuery(lCon,"INSERT INTO CUSTOMER VALUES (3, 'GreenLeaf Industries','778899','Calle de la Luna, 27','SPAIN','CCC','Manufacturing', 'Alejandro Garc\u00EDa Lopez', 'alejandro@greenleaf.com','778899')");
			}
			
			//Create the ORDER Table and populate it
			//CREATE TABLE orders (id INT PRIMARY KEY,customer_id INT,order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,status VARCHAR(20),total_amount DECIMAL(10,2),currency VARCHAR(3),payment_method VARCHAR(50),shipping_address VARCHAR(150));
			
			if( !existTable("CUSTOMERORDER")){ 
				executeQuery(lCon,"CREATE TABLE CUSTOMERORDER ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, customer_id INT, order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,status VARCHAR(20),total_amount DECIMAL(10,2),currency VARCHAR(3),payment_method VARCHAR(50),shipping_address VARCHAR(150))");
		
				//INSERT INTO CUSTOMERORDER (customer_id,status,total_amount,currency,payment_method,shipping_address) VALUES (101,'NEW',199.99,'SEK','CreditCard','Acmestreet 1')
		
				executeQuery(lCon,"INSERT INTO CUSTOMERORDER (id, customer_id,status,total_amount,currency,payment_method,shipping_address) VALUES (1,1,'NEW',100.00,'EUR','CREDITCARD','Acmestreet 1')");
			}
			
			//CREATE TABLE ORDERROWS (id INT PRIMARY KEY,order_id INT NOT NULL,product_id INT NOT NULL,product_name VARCHAR(100),quantity INT NOT NULL, unit_price DECIMAL(10,2) NOT NULL, total_price DECIMAL(10,2) NOT NULL, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP);
			
			if( !existTable("ORDERROW")){ 
				executeQuery(lCon,"CREATE TABLE ORDERROW (id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,order_id INT NOT NULL,product_id INT NOT NULL,product_name VARCHAR(100),quantity INT NOT NULL, unit_price DECIMAL(10,2) NOT NULL, total_price DECIMAL(10,2) NOT NULL, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)");
				executeQuery(lCon,"INSERT INTO ORDERROW (id, order_id,product_id,product_name,quantity,unit_price,total_price) VALUES (1,1,1,'Hammer',10,10.00,100.00)");
			}
			
			//Create the INVENTORY Table and populate it
			//CREATE TABLE inventory (id INT PRIMARY KEY,product_name VARCHAR(100),quantity_in_stock INT NOT NULL,reorder_level INT DEFAULT 10,unit_price DECIMAL(10,2),warehouse_location VARCHAR(50),last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP)
		
			if( !existTable("INVENTORY")){ 
				executeQuery(lCon,"CREATE TABLE INVENTORY (id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,product_name VARCHAR(100),quantity_in_stock INT NOT NULL,reorder_level INT DEFAULT 10,unit_price DECIMAL(10,2),selling_price DECIMAL(10,2),currency VARCHAR(3),warehouse_location VARCHAR(50),last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP)");
		
				executeQuery(lCon,"INSERT INTO INVENTORY (id, product_name,quantity_in_stock,reorder_level,unit_price,selling_price,currency,warehouse_location) VALUES (1,'Hammer',100,10,8.00,10.00,'EUR','Warehouse1')");
				executeQuery(lCon,"INSERT INTO INVENTORY (id, product_name,quantity_in_stock,reorder_level,unit_price,selling_price,currency,warehouse_location) VALUES (2,'ScrewDriver',50,10,4.50,5.50,'EUR','Warehouse1')");
				executeQuery(lCon,"INSERT INTO INVENTORY (id, product_name,quantity_in_stock,reorder_level,unit_price,selling_price,currency,warehouse_location) VALUES (3,'Chair',20,4,30.00,35.75,'EUR','Warehouse1')");
				executeQuery(lCon,"INSERT INTO INVENTORY (id, product_name,quantity_in_stock,reorder_level,unit_price,selling_price,currency,warehouse_location) VALUES (4,'Tables',10,4,100.00,145.00,'EUR','Warehouse1')");
			}
			
			//Create the INVOICE Table and populate it
		
			//CREATE TABLE INVOICE (id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, customer_id INT NOT NULL,order_id INT NOT NULL,invoice_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,due_date TIMESTAMP, status VARCHAR(20), total_amount DECIMAL(10,2), currency VARCHAR(3), payment_terms VARCHAR(20),  notes VARCHAR(255))
		
			if( !existTable("INVOICE")){ 
				executeQuery(lCon,"CREATE TABLE INVOICE (id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, customer_id INT NOT NULL, order_id INT NOT NULL, invoice_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP, due_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP, status VARCHAR(20), total_amount DECIMAL(10,2), currency VARCHAR(3), payment_terms VARCHAR(20),  notes VARCHAR(255))");
				executeQuery(lCon,"INSERT INTO INVOICE (id, customer_id,order_id,due_date,total_amount,currency,payment_terms,notes) VALUES (1,1,1,CURRENT_TIMESTAMP + INTERVAL '30' DAY,100.00,'EUR','30 days','Shipped from Warehouse1')");
			}
		
			//Create the PAYMENT Table and populate it
			//CREATE TABLE payments ( id INT PRIMARY KEY, order_id INT NOT NULL, invoice_id,payment_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP, amount DECIMAL(10,2) NOT NULL, currency VARCHAR(3) NOT NULL, payment_method VARCHAR(50), status VARCHAR(20), transaction_reference VARCHAR(100))
			
			if( !existTable("PAYMENT")){ 
				executeQuery(lCon,"CREATE TABLE PAYMENT ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, order_id INT NOT NULL, invoice_id INT NOT NULL, payment_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP, amount DECIMAL(10,2) NOT NULL, currency VARCHAR(3) NOT NULL, payment_method VARCHAR(50), status VARCHAR(20), transaction_reference VARCHAR(100))");
				executeQuery(lCon,"INSERT INTO PAYMENT (id, order_id, invoice_id, amount, currency, payment_method, status, transaction_reference) VALUES (1,1,1,100.00,'EUR','INVOICE','PAYED','BANKTRANSFER:111111')");
			}
		
		
			//Create the EMAIL Table and populate it
		
			if( !existTable("EMAIL")){ 
				executeQuery(lCon,"CREATE TABLE EMAIL ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, recipient VARCHAR(150) NOT NULL, subject VARCHAR(200),  body VARCHAR(500), sent_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP)");
				executeQuery(lCon,"INSERT INTO EMAIL (id, recipient, subject, body) VALUES (1,'andrew.smith@acme.com','INVOICE','See attached Invoce of 100 EUR, Please pay within 30 days')");
			}
		
			if( !existTable("USER")){ 
				executeQuery(lCon,"CREATE TABLE USER (id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, customer_id INT NOT NULL, name VARCHAR(50),email VARCHAR(100),phone VARCHAR(50) )");
				executeQuery(lCon,"INSERT INTO USER VALUES (1,1, 'Alice Wonderful','alice.wonderful@acme.com', '112233')");
				executeQuery(lCon,"INSERT INTO USER VALUES (2,3, 'Bob bobson','bob.bobson@greenleaf.com','778899')");
			}
		} 
		catch (SQLException e) {
				IDataCursor pipelineCursor_1 = pipeline.getCursor();
				IDataUtil.put( pipelineCursor_1, "DBError", "Cannot create Tables: "+e.getMessage());
				pipelineCursor_1.destroy();
		}
		 
		IDataCursor pipelineCursor_1 = pipeline.getCursor();
		IDataUtil.put( pipelineCursor_1, "connection", lCon);
		
		pipelineCursor_1.destroy();
		// --- <<IS-END>> ---

                
	}



	public static final void queryTable (IData pipeline)
        throws ServiceException
	{
		// --- <<IS-START(queryTable)>> ---
		// @sigtype java 3.5
		// [i] field:0:required queryType {"SELECT","INSERT","UPDATE","DELETE","QUERY","SEARCH"}
		// [i] record:0:optional SELECT
		// [i] - field:0:required table
		// [i] - field:0:optional id
		// [i] - field:0:optional whereclause
		// [i] record:0:optional INSERT
		// [i] - field:0:required table
		// [i] - record:0:required document
		// [i] record:0:optional UPDATE
		// [i] - field:0:required table
		// [i] - record:0:required document
		// [i] - field:0:optional id
		// [i] - field:0:optional whereclause
		// [i] record:0:optional DELETE
		// [i] - field:0:required table
		// [i] - field:0:optional id
		// [i] - field:0:optional whereclause
		// [i] record:0:optional QUERY
		// [i] - field:0:required query
		// [i] record:0:optional SEARCH
		// [i] - field:0:required table
		// [i] - record:0:required document
		// [o] record:1:required Result
		// [o] field:0:required rowsAffected
		// [o] field:0:optional ID
		// pipeline
		IDataCursor pipelineCursor = pipeline.getCursor();
		String	lQueryType = IDataUtil.getString( pipelineCursor, "queryType" );
		IData[] lDocumentList = null;
		int lNumberOfRows = 0;
		int lRecordId =0;
		
		try {
			Connection lCon=getDatabaseConnection();
		
			if(lQueryType.equals("QUERY")){
				// QUERY
				IData	QUERY = IDataUtil.getIData( pipelineCursor, "QUERY" );
				if ( QUERY != null)
				{
					IDataCursor QUERYCursor = QUERY.getCursor();
					String	lQuery = IDataUtil.getString( QUERYCursor, "query" );
					QUERYCursor.destroy();
					ResultSet lResult = executeQuery(lCon, lQuery);
					lDocumentList = getResultAsIData(lResult);
					if(lDocumentList != null) lNumberOfRows = lResult.getRow();
				}
			}
			if(lQueryType.equals("SELECT")){
				// SELECT
				IData	SELECT = IDataUtil.getIData( pipelineCursor, "SELECT" );
				if ( SELECT != null)
				{
					IDataCursor SELECTCursor = SELECT.getCursor();
					String	lTable = IDataUtil.getString( SELECTCursor, "table" );
					String	lId = IDataUtil.getString( SELECTCursor, "id" );
					String	lInputWhereclause = IDataUtil.getString( SELECTCursor, "whereclause" );
					String lWhereClause = handleWhereClause(lId,lInputWhereclause );
					ResultSet lResult = select(lCon,lTable, lWhereClause);
					lDocumentList = getResultAsIData(lResult);
					if(lDocumentList != null)
						lNumberOfRows = lDocumentList.length;
					SELECTCursor.destroy();
				}
		
			}
			
			if(lQueryType.equals("INSERT")){
				// INSERT
				IData	INSERT = IDataUtil.getIData( pipelineCursor, "INSERT" );
				if ( INSERT != null){
					IDataCursor INSERTCursor = INSERT.getCursor();
					String	lTable = IDataUtil.getString( INSERTCursor, "table" );
					// i.document
					IData	document = IDataUtil.getIData( INSERTCursor, "document" );
					if ( document != null){
						Map<String, Object> fieldsMap = new HashMap<>();
						IDataCursor docCursor = document.getCursor();
						   // Iterate through all fields
						    while (docCursor.next()) {
						        String key = docCursor.getKey();
						        Object value = docCursor.getValue();
						        fieldsMap.put(key, value);
						    }
						    int[] lRetTemp = insert(lCon,lTable,fieldsMap);
						    lNumberOfRows = lRetTemp[0];
						    lRecordId = lRetTemp[1];
						    docCursor.destroy();
					}
					INSERTCursor.destroy();
				}
			}
			
			if(lQueryType.equals("UPDATE")){
				// UPDATE
				IData	UPDATE = IDataUtil.getIData( pipelineCursor, "UPDATE" );
				if ( UPDATE != null){
						IDataCursor UPDATECursor = UPDATE.getCursor();
						String	lTable = IDataUtil.getString( UPDATECursor, "table" );
						String	lId = IDataUtil.getString( UPDATECursor, "id" );
						String	lInputWhereclause = IDataUtil.getString( UPDATECursor, "whereclause" );
						String lWhereClause = handleWhereClause(lId,lInputWhereclause );
						// i.document
						IData document = IDataUtil.getIData( UPDATECursor, "document" );
						if ( document != null){
							Map<String, Object> fieldsMap = new HashMap<>();
							IDataCursor docCursor = document.getCursor();
							   // Iterate through all fields
							    while (docCursor.next()) {
							        String key = docCursor.getKey();
							        Object value = docCursor.getValue();
							        fieldsMap.put(key, value);
							    }
							    lNumberOfRows = update(lCon,lTable,fieldsMap,lWhereClause);
							    IDataUtil.put( UPDATECursor, "WhereClause", lWhereClause );
							    docCursor.destroy();
						}//id
						UPDATECursor.destroy();
				}//if
			} 
			if(lQueryType.equals("DELETE")){
				// DELETE
				IData	DELETE = IDataUtil.getIData( pipelineCursor, "DELETE" );
				if ( DELETE != null)
				{
					IDataCursor DELETECursor = DELETE.getCursor();
					String	lTable = IDataUtil.getString( DELETECursor, "table" );
					String	lId = IDataUtil.getString( DELETECursor, "id" );
					String	lInputWhereclause = IDataUtil.getString( DELETECursor, "whereclause" );
					String lWhereClause = handleWhereClause(lId,lInputWhereclause );
					lNumberOfRows = delete(lCon, lTable, lWhereClause);
					DELETECursor.destroy();
				}
		
			}
			if(lQueryType.equals("SEARCH")){
				// SEARCH
				IData	SEARCH = IDataUtil.getIData( pipelineCursor, "SEARCH" );
				if ( SEARCH != null)
				{
					IDataCursor SEARCHCursor = SEARCH.getCursor();
					// i.searchDoc
					String	lTable = IDataUtil.getString( SEARCHCursor, "table" );
					IData	document = IDataUtil.getIData( SEARCHCursor, "document" );
					if ( document != null)
					{
						Map<String, Object> fieldsMap = new HashMap<>();
						IDataCursor docCursor = document.getCursor();
						// Iterate through all fields
						while (docCursor.next()) {
							String key = docCursor.getKey();
							Object value = docCursor.getValue();
							fieldsMap.put(key, value);
						}
						docCursor.destroy();
						ResultSet lResult = search(lCon,lTable,fieldsMap);
						lDocumentList = getResultAsIData(lResult);
						if(lDocumentList != null)
							lNumberOfRows = lDocumentList.length;
		
					}//if
					SEARCHCursor.destroy();
				}
				pipelineCursor.destroy();
		
			}
		} 
		catch (SQLException e) {
			IDataCursor pipelineCursor_e = pipeline.getCursor();
			IDataUtil.put( pipelineCursor_e, "Error: ", e.getMessage());
			pipelineCursor_e.destroy();
		}
		
		
			IDataUtil.put( pipelineCursor, "Result", lDocumentList );
			IDataUtil.put( pipelineCursor, "rowsAffected", String.valueOf(lNumberOfRows));
			IDataUtil.put( pipelineCursor, "ID", String.valueOf(lRecordId) );
			pipelineCursor.destroy();
		// --- <<IS-END>> ---

                
	}

	// --- <<IS-START-SHARED>> ---
	
		static Connection mCon =null;
	
	    public static java.sql.Connection getDatabaseConnection() throws SQLException {
			 try {
			        Class.forName("org.hsqldb.jdbc.JDBCDriver");
			 } 
			 catch (ClassNotFoundException e) {
				 throw new java.sql.SQLException("Can not load driver for hsgldb");
			 }
			if( mCon != null){
				return mCon;
			}else{
				mCon = DriverManager.getConnection("jdbc:hsqldb:mem:demodb","SA","");
				return mCon;
			}
	    }
	    
	    public static boolean existTable(String pTableName) throws SQLException{
	    	boolean lreturn = false;
	        // \u2705 Check if table exists
	        DatabaseMetaData meta = getDatabaseConnection().getMetaData();
	        ResultSet tables = meta.getTables(null, null, pTableName.toUpperCase(), null);
	
	        if (tables.next()) {
	        	lreturn = true;
	        } else {
	        	lreturn = false;
	        }
			return lreturn;
	    }
	    
	    public static String[] getTables() throws SQLException{
	    	String[] lTableNames = null;
	    	Connection conn = getDatabaseConnection();
	
	    	DatabaseMetaData meta = conn.getMetaData();
	    	ResultSet rs = meta.getTables(null, null, "%", new String[]{"TABLE"});
	
	    	List<String> tables = new ArrayList<>();
	
	    	while (rs.next()) {
	    		tables.add(rs.getString("TABLE_NAME"));
	    	}//while
	
	    	lTableNames = new String[tables.size()];
	    	lTableNames = tables.toArray(lTableNames);
	    	return lTableNames;
	
	    }
	
	    public static ResultSet executeQuery(java.sql.Connection pConn, String pQuery) throws SQLException {
	        Statement stmt = pConn.createStatement();
	        return stmt.executeQuery(pQuery);
	    }
	
	    public static ResultSet select(java.sql.Connection pConn,String pTable, String pWhereClause) throws SQLException {
	    	String sql = "SELECT * FROM " + pTable;
	    	if( pWhereClause != null && !pWhereClause.equals("")){
	        	sql = sql + (pWhereClause != null ? " WHERE " + pWhereClause : "");
	        }
	        return executeQuery(pConn, sql);
	    }
	
	    
	    public static int[] insert(java.sql.Connection pConn, String pTable, Map<String, Object> pValues) throws SQLException {
	        int[] retvalue = new int[2];
	    	String columns = String.join(", ", pValues.keySet());
	        String placeholders = String.join(", ", Collections.nCopies(pValues.size(), "?"));
	        String sql = "INSERT INTO " + pTable + " (" + columns + ") VALUES (" + placeholders + ")";
	        try (PreparedStatement ps = pConn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
	            int i = 1;
	            for (Object val : pValues.values()) {
	                ps.setObject(i++, val);
	            }
	            retvalue[0] =  ps.executeUpdate();
	
	            ResultSet keys = ps.getGeneratedKeys();
	            if (keys.next()) {
	            	int generatedId = keys.getInt(1);
	            	retvalue[1] = generatedId;
	            }
	        }
	        return retvalue;
	    }
	    
	    public static int update(java.sql.Connection pConn,String pTable, Map<String, Object> pValues, String pWhereClause) throws SQLException {
	        String setClause = String.join(", ", pValues.keySet().stream().map(k -> k + "=?").toList());
	        String sql = "UPDATE " + pTable + " SET " + setClause + " WHERE " + pWhereClause;
	        
	        try (PreparedStatement ps = pConn.prepareStatement(sql)) {
	            int i = 1;
	            for (Object val : pValues.values()) {
	                ps.setObject(i++, val);
	            }
	            return ps.executeUpdate();
	        }
	    }
	    
	    public static int delete(java.sql.Connection pConn, String pTable, String pWhereClause) throws SQLException {
	    	String sql = "DELETE FROM " + pTable;
	    	if( pWhereClause != null && !pWhereClause.equals("")){
	        	sql = sql + (pWhereClause != null ? " WHERE " + pWhereClause : "");
	        }
	        try (PreparedStatement ps = pConn.prepareStatement(sql)) {
	            return ps.executeUpdate();
	        }
	    }
	
	    public static ResultSet search(java.sql.Connection pConn,String pTable, Map<String, Object> pValues) throws SQLException {
	    	String sql = "SELECT * FROM " + pTable;
	    	if( pValues != null && pValues.size() > 0){
	    		String lWhereClause = "";
	
	    		for (String key : pValues.keySet()) {
	    			String lValue = (String) pValues.get(key);
	    			if(!lWhereClause.equals(""))
	    				lWhereClause = lWhereClause+" AND ";
	    			lWhereClause = lWhereClause + key +"='"+lValue+"' ";
	    		}
	        	sql = sql + (lWhereClause != null ? " WHERE " + lWhereClause : "");
	        }
	        return executeQuery(pConn, sql);
	    }
	
	    public static String handleWhereClause(String pId,String pInputWhereClause){
			String lWhereClause = "";
			
			if( pId != null && !pId.equals("")){
				lWhereClause= "ID ="+pId;
			}
			
			if( pInputWhereClause != null && !pInputWhereClause.equals("")){
				if(!lWhereClause.equals(""))
					lWhereClause= lWhereClause + " and ";
				lWhereClause = lWhereClause + pInputWhereClause;
			}
	
			return lWhereClause;
	    }
	    
	    /**
	     * @param pResult
	     * @return IData[]
	     * @throws SQLException
	     */
	    public static IData[] getResultAsIData(ResultSet pResult ) throws SQLException{
	    	ArrayList<IData> lReturnList = new ArrayList<IData>();
	
	       ResultSetMetaData meta = pResult.getMetaData();
	       int columnCount = meta.getColumnCount();
	
			while(pResult.next()){
				IData lreturnIData = IDataFactory.create();
				IDataCursor retCursor = lreturnIData.getCursor();
	            for (int i = 1; i <= columnCount; i++) {
	                   String columnName = meta.getColumnName(i);
	                   Object value = pResult.getObject(i);
	                   IDataUtil.put(retCursor,columnName,String.valueOf(value));
	            }
	            lReturnList.add(lreturnIData);
				//Create the users Table
				//Create the users TableexecuteQuery(lCon,"executeQuery(lCon,"executeQuery(lCon,"(lreturnIData);
			}//while
			IData[] DocumentList = new IData[lReturnList.size()];
			return lReturnList.toArray(DocumentList);
	
	    	
	    }
	
	    /*
	    
	    public int update(String table, Map<String, Object> values, String whereClause) throws SQLException {
	        String setClause = String.join(", ", values.keySet().stream().map(k -> k + "=?").toList());
	        String sql = "UPDATE " + table + " SET " + setClause + " WHERE " + whereClause;
	        try (PreparedStatement ps = conn.prepareStatement(sql)) {
	            int i = 1;
	            for (Object val : values.values()) {
	                ps.setObject(i++, val);
	            }
	            return ps.executeUpdate();
	        }
	    }
	
	    public int delete(String table, String whereClause) throws SQLException {
	        String sql = "DELETE FROM " + table + " WHERE " + whereClause;
	        try (PreparedStatement ps = conn.prepareStatement(sql)) {
	            return ps.executeUpdate();
	        }
	    }
	*/	
	// --- <<IS-END-SHARED>> ---
}

